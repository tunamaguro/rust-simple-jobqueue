//! Code generated by sqlc-gen-rust. SHOULD NOT EDIT.
//! sqlc version: v1.28.0
//! sqlc-gen-rust version: v0.1.6

pub struct CopyDataSink<C: std::ops::DerefMut<Target = sqlx::PgConnection>> {
    encode_buf: sqlx::postgres::PgArgumentBuffer,
    data_buf: Vec<u8>,
    copy_in: sqlx::postgres::PgCopyIn<C>,
}
impl<C: std::ops::DerefMut<Target = sqlx::PgConnection>> CopyDataSink<C> {
    const BUFFER_SIZE: usize = 4096;
    fn new(copy_in: sqlx::postgres::PgCopyIn<C>) -> Self {
        let mut data_buf = Vec::with_capacity(Self::BUFFER_SIZE);
        const COPY_SIGNATURE: &[u8] = &[
            b'P', b'G', b'C', b'O', b'P', b'Y', b'\n', 0xFF, b'\r', b'\n', 0x00,
        ];
        assert_eq!(COPY_SIGNATURE.len(), 11);
        data_buf.extend_from_slice(COPY_SIGNATURE);
        data_buf.extend(0_i32.to_be_bytes());
        data_buf.extend(0_i32.to_be_bytes());
        CopyDataSink {
            encode_buf: Default::default(),
            data_buf,
            copy_in,
        }
    }
    async fn send(&mut self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        let _copy_in = self.copy_in.send(self.data_buf.as_slice()).await?;
        self.data_buf.clear();
        Ok(())
    }
    /// Complete copy process and return number of rows affected.
    pub async fn finish(
        mut self,
    ) -> Result<u64, Box<dyn std::error::Error + Send + Sync>> {
        const COPY_TRAILER: &[u8] = &(-1_i16).to_be_bytes();
        self.data_buf.extend(COPY_TRAILER);
        self.send().await?;
        self.copy_in.finish().await.map_err(|e| e.into())
    }
    fn insert_row(&mut self) {
        let num_col = self.copy_in.num_columns() as i16;
        self.data_buf.extend(num_col.to_be_bytes());
    }
    async fn add<'q, T>(
        &mut self,
        value: &T,
    ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>
    where
        T: sqlx::Encode<'q, sqlx::Postgres> + sqlx::Type<sqlx::Postgres>,
    {
        let is_null = value.encode_by_ref(&mut self.encode_buf)?;
        match is_null {
            sqlx::encode::IsNull::Yes => {
                self.data_buf.extend((-1_i32).to_be_bytes());
            }
            sqlx::encode::IsNull::No => {
                self.data_buf.extend((self.encode_buf.len() as i32).to_be_bytes());
                self.data_buf.extend_from_slice(self.encode_buf.as_slice());
            }
        }
        self.encode_buf.clear();
        if self.data_buf.len() > Self::BUFFER_SIZE {
            self.send().await?;
        }
        Ok(())
    }
}
#[derive(Debug, Clone, Copy, sqlx::Type)]
#[sqlx(type_name = "job_status")]
pub enum JobStatus {
    #[sqlx(rename = "pending")]
    Pending,
    #[sqlx(rename = "running")]
    Running,
    #[sqlx(rename = "completed")]
    Completed,
    #[sqlx(rename = "failed")]
    Failed,
}
#[derive(sqlx::FromRow)]
pub struct PollJobsRow {
    pub id: sqlx::types::Uuid,
    pub args: serde_json::Value,
}
pub struct PollJobs {
    limit: i32,
}
impl PollJobs {
    pub const QUERY: &'static str = r"WITH picked AS (
  SELECT id, scheduled_at
  FROM jobs
  WHERE status = 'pending'
  ORDER BY scheduled_at ASC
  FOR UPDATE SKIP LOCKED
  LIMIT $1
),
updated AS (
  UPDATE jobs j
  SET status = 'running'
  FROM picked
  WHERE j.id = picked.id
  RETURNING j.id, j.args, j.scheduled_at
)
SELECT id, args
FROM updated
ORDER BY scheduled_at ASC";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        PollJobsRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, PollJobsRow>(Self::QUERY).bind(self.limit)
    }
    pub fn query_many<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<Output = Result<Vec<PollJobsRow>, sqlx::Error>> + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            let vals = self.query_as().fetch_all(&mut *conn).await?;
            Ok(vals)
        }
    }
}
impl PollJobs {
    pub const fn builder() -> PollJobsBuilder<'static, ((),)> {
        PollJobsBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct PollJobsBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> PollJobsBuilder<'a, ((),)> {
    pub fn limit(self, limit: i32) -> PollJobsBuilder<'a, (i32,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        PollJobsBuilder {
            fields: (limit,),
            _phantom,
        }
    }
}
impl<'a> PollJobsBuilder<'a, (i32,)> {
    pub const fn build(self) -> PollJobs {
        let (limit,) = self.fields;
        PollJobs { limit }
    }
}
#[derive(sqlx::FromRow)]
pub struct CompleteJobRow {}
pub struct CompleteJob {
    id: sqlx::types::Uuid,
}
impl CompleteJob {
    pub const QUERY: &'static str = r"UPDATE jobs
SET status = 'completed'
WHERE id = $1";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        CompleteJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, CompleteJobRow>(Self::QUERY).bind(self.id)
    }
    pub fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<
        Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>,
    > + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY).bind(self.id).execute(&mut *conn).await
        }
    }
}
impl CompleteJob {
    pub const fn builder() -> CompleteJobBuilder<'static, ((),)> {
        CompleteJobBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct CompleteJobBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> CompleteJobBuilder<'a, ((),)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> CompleteJobBuilder<'a, (sqlx::types::Uuid,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        CompleteJobBuilder {
            fields: (id,),
            _phantom,
        }
    }
}
impl<'a> CompleteJobBuilder<'a, (sqlx::types::Uuid,)> {
    pub const fn build(self) -> CompleteJob {
        let (id,) = self.fields;
        CompleteJob { id }
    }
}
#[derive(sqlx::FromRow)]
pub struct FailJobRow {}
pub struct FailJob {
    id: sqlx::types::Uuid,
}
impl FailJob {
    pub const QUERY: &'static str = r"UPDATE jobs
SET status = 'failed'
WHERE id = $1";
    pub fn query_as<'a>(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        FailJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, FailJobRow>(Self::QUERY).bind(self.id)
    }
    pub fn execute<'a, 'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<
        Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>,
    > + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY).bind(self.id).execute(&mut *conn).await
        }
    }
}
impl FailJob {
    pub const fn builder() -> FailJobBuilder<'static, ((),)> {
        FailJobBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct FailJobBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> FailJobBuilder<'a, ((),)> {
    pub fn id(self, id: sqlx::types::Uuid) -> FailJobBuilder<'a, (sqlx::types::Uuid,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        FailJobBuilder {
            fields: (id,),
            _phantom,
        }
    }
}
impl<'a> FailJobBuilder<'a, (sqlx::types::Uuid,)> {
    pub const fn build(self) -> FailJob {
        let (id,) = self.fields;
        FailJob { id }
    }
}
#[derive(sqlx::FromRow)]
pub struct RetryJobRow {}
pub struct RetryJob<'a> {
    id: sqlx::types::Uuid,
    interval: &'a sqlx::postgres::types::PgInterval,
}
impl<'a> RetryJob<'a> {
    pub const QUERY: &'static str = r"UPDATE jobs
SET status = 'pending',
    scheduled_at = NOW() + $2::interval
WHERE id = $1";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        RetryJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, RetryJobRow>(Self::QUERY).bind(self.id).bind(self.interval)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<
        Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>,
    > + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY)
                .bind(self.id)
                .bind(self.interval)
                .execute(&mut *conn)
                .await
        }
    }
}
impl<'a> RetryJob<'a> {
    pub const fn builder() -> RetryJobBuilder<'a, ((), ())> {
        RetryJobBuilder {
            fields: ((), ()),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct RetryJobBuilder<'a, Fields = ((), ())> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a, Interval> RetryJobBuilder<'a, ((), Interval)> {
    pub fn id(
        self,
        id: sqlx::types::Uuid,
    ) -> RetryJobBuilder<'a, (sqlx::types::Uuid, Interval)> {
        let ((), interval) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (id, interval),
            _phantom,
        }
    }
}
impl<'a, Id> RetryJobBuilder<'a, (Id, ())> {
    pub fn interval(
        self,
        interval: &'a sqlx::postgres::types::PgInterval,
    ) -> RetryJobBuilder<'a, (Id, &'a sqlx::postgres::types::PgInterval)> {
        let (id, ()) = self.fields;
        let _phantom = self._phantom;
        RetryJobBuilder {
            fields: (id, interval),
            _phantom,
        }
    }
}
impl<
    'a,
> RetryJobBuilder<'a, (sqlx::types::Uuid, &'a sqlx::postgres::types::PgInterval)> {
    pub const fn build(self) -> RetryJob<'a> {
        let (id, interval) = self.fields;
        RetryJob { id, interval }
    }
}
#[derive(sqlx::FromRow)]
pub struct InsertJobRow {}
pub struct InsertJob<'a> {
    job_data: &'a serde_json::Value,
}
impl<'a> InsertJob<'a> {
    pub const QUERY: &'static str = r"INSERT INTO jobs (args) VALUES ($1)";
    pub fn query_as(
        &'a self,
    ) -> sqlx::query::QueryAs<
        'a,
        sqlx::Postgres,
        InsertJobRow,
        <sqlx::Postgres as sqlx::Database>::Arguments<'a>,
    > {
        sqlx::query_as::<_, InsertJobRow>(Self::QUERY).bind(self.job_data)
    }
    pub fn execute<'b, A>(
        &'a self,
        conn: A,
    ) -> impl Future<
        Output = Result<<sqlx::Postgres as sqlx::Database>::QueryResult, sqlx::Error>,
    > + Send + 'a
    where
        A: sqlx::Acquire<'b, Database = sqlx::Postgres> + Send + 'a,
    {
        async move {
            let mut conn = conn.acquire().await?;
            sqlx::query(Self::QUERY).bind(self.job_data).execute(&mut *conn).await
        }
    }
}
impl<'a> InsertJob<'a> {
    pub const fn builder() -> InsertJobBuilder<'a, ((),)> {
        InsertJobBuilder {
            fields: ((),),
            _phantom: std::marker::PhantomData,
        }
    }
}
pub struct InsertJobBuilder<'a, Fields = ((),)> {
    fields: Fields,
    _phantom: std::marker::PhantomData<&'a ()>,
}
impl<'a> InsertJobBuilder<'a, ((),)> {
    pub fn job_data(
        self,
        job_data: &'a serde_json::Value,
    ) -> InsertJobBuilder<'a, (&'a serde_json::Value,)> {
        let ((),) = self.fields;
        let _phantom = self._phantom;
        InsertJobBuilder {
            fields: (job_data,),
            _phantom,
        }
    }
}
impl<'a> InsertJobBuilder<'a, (&'a serde_json::Value,)> {
    pub const fn build(self) -> InsertJob<'a> {
        let (job_data,) = self.fields;
        InsertJob { job_data }
    }
}
